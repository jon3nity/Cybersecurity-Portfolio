"""
malware_callback_sim.py — Command-and-Control Beaconing Simulator

Generates network logs that mimic malware communicating with a C2 server.
Models realistic beaconing patterns including:
    - Fixed-interval HTTP callbacks (like Cobalt Strike default)
    - Jittered intervals (evasion technique)
    - DNS tunneling for covert C2
    - Data-bearing callbacks (command responses)

    MITRE ATT&CK:
    - T1071.001 — Application Layer Protocol: Web Protocols
    - T1071.004 — Application Layer Protocol: DNS
    - T1573.001 — Encrypted Channel: Symmetric Cryptography

Detection challenge:
    C2 beaconing hides in normal web/DNS traffic. The key indicators
    are regularity of intervals, unusual domain patterns, and data
    encoded in DNS queries.

Usage:
    python malware_callback_sim.py --events 200 --beacon-interval 60
    python malware_callback_sim.py --events 500 --protocol dns --jitter 0.2
"""

import sys
import random
import string
import hashlib
import argparse
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, Any, List

sys.path.insert(0, str(Path(__file__).parent.parent))
import config
from data_generators.base_generator import BaseGenerator


class MalwareCallbackSimulator(BaseGenerator):
    """
    Simulate C2 beaconing patterns that detection rules must identify
    among legitimate web and DNS traffic.
    
    Key realism features:
    - Consistent beacon intervals with configurable jitter
    - Encoded payloads in HTTP POST bodies and DNS subdomains
    - Multiple infected hosts communicating with same C2
    - Mixed HTTP and DNS channels
    """

    # Suspicious C2 domains (simulated)
    C2_DOMAINS = [
        "update-service-cdn.com",
        "api-analytics-track.net",
        "cloud-sync-node42.io",
        "telemetry-endpoint.xyz",
        "content-delivery-fast.com",
    ]

    # Legitimate domains for benign DNS/HTTP traffic
    LEGIT_DOMAINS = [
        "google.com", "microsoft.com", "github.com", "amazonaws.com",
        "cloudflare.com", "office365.com", "slack.com", "zoom.us",
        "linkedin.com", "salesforce.com", "atlassian.net",
    ]

    # C2 URI paths mimicking legitimate services
    C2_URI_PATHS = [
        "/api/v2/check", "/update/config.json", "/cdn/pixel.gif",
        "/analytics/event", "/sync/status", "/health", "/v1/telemetry",
        "/static/beacon.js", "/api/heartbeat", "/metrics/collect",
    ]

    def __init__(
        self,
        beacon_interval: int = 60,
        jitter: float = 0.1,
        protocol: str = "http",
        **kwargs,
    ):
        super().__init__(
            name="malware_callback",
            sourcetype="attack_sim:proxy",
            **kwargs,
        )
        self.beacon_interval = beacon_interval  # seconds between callbacks
        self.jitter = jitter  # 0.0–1.0, randomness in interval
        self.protocol = protocol  # "http" or "dns"

        # Select infected hosts (subset of internal machines)
        self.infected_hosts = random.sample(
            list(config.TARGET_HOSTS.items()), k=min(3, len(config.TARGET_HOSTS))
        )

    def generate_malicious_event(self, timestamp: str) -> Dict[str, Any]:
        """
        Produce a C2 beacon event — either HTTP callback or DNS query
        depending on configured protocol.
        """
        if self.protocol == "dns":
            return self._generate_dns_beacon(timestamp)
        return self._generate_http_beacon(timestamp)

    def _generate_http_beacon(self, timestamp: str) -> Dict[str, Any]:
        """
        HTTP C2 beacon: POST to C2 domain with encoded payload.
        
        Mimics Cobalt Strike / Sliver / Mythic callback pattern:
        - Regular interval to same endpoint
        - Small POST body with encoded data
        - Custom or generic User-Agent
        """
        host_name, host_info = random.choice(self.infected_hosts)
        c2_domain = random.choice(self.C2_DOMAINS)
        c2_ip = random.choice(config.EXTERNAL_ATTACKER_IPS)
        uri = random.choice(self.C2_URI_PATHS)

        # Simulated encoded payload (base64-like data)
        payload_size = random.randint(64, 2048)
        payload_data = "".join(random.choices(string.ascii_letters + string.digits, k=payload_size))

        # Response size varies — small for check-ins, large for commands
        response_size = random.choice([128, 256, 512, 4096, 8192])

        return {
            "timestamp": timestamp,
            "event_type": "http_request",
            "hostname": host_name,
            "src_ip": host_info["ip"],
            "dst_ip": c2_ip,
            "dst_port": random.choice([80, 443, 8080, 8443]),
            "method": random.choice(["POST", "GET"]),
            "url": f"https://{c2_domain}{uri}",
            "domain": c2_domain,
            "status_code": 200,
            "bytes_out": payload_size,
            "bytes_in": response_size,
            "user_agent": f"Mozilla/5.0 (Windows NT 10.0; Win64; x64) {hashlib.md5(c2_domain.encode()).hexdigest()[:8]}",
            "content_type": "application/octet-stream",
            "severity": 3,
            "mitre_technique": config.MITRE_TECHNIQUES["c2_http"]["id"],
            "mitre_tactic": config.MITRE_TECHNIQUES["c2_http"]["tactic"],
            "beacon_interval": self.beacon_interval,
            "message": f"C2 HTTP beacon from {host_info['ip']} to {c2_domain}{uri}",
            "is_malicious": True,
        }

    def _generate_dns_beacon(self, timestamp: str) -> Dict[str, Any]:
        """
        DNS tunneling beacon: encode data in subdomain queries.
        
        Pattern: <encoded_data>.c2domain.com
        Detection key: Unusually long subdomain labels, high query frequency
        to a single domain, TXT record requests.
        """
        host_name, host_info = random.choice(self.infected_hosts)
        c2_domain = random.choice(self.C2_DOMAINS)

        # Encode simulated exfil data as hex subdomain
        encoded_data = "".join(random.choices(string.hexdigits.lower(), k=random.randint(20, 60)))
        query_name = f"{encoded_data}.{c2_domain}"

        # DNS tunneling often uses TXT or NULL record types
        record_type = random.choice(["A", "TXT", "TXT", "CNAME", "NULL"])

        return {
            "timestamp": timestamp,
            "event_type": "dns_query",
            "hostname": host_name,
            "src_ip": host_info["ip"],
            "dst_ip": "10.0.2.5",  # Internal DNS server
            "dst_port": 53,
            "query_name": query_name,
            "query_type": record_type,
            "domain": c2_domain,
            "subdomain_length": len(encoded_data),
            "response_code": "NOERROR",
            "severity": 3,
            "mitre_technique": config.MITRE_TECHNIQUES["c2_dns"]["id"],
            "mitre_tactic": config.MITRE_TECHNIQUES["c2_dns"]["tactic"],
            "message": f"DNS tunnel query from {host_info['ip']}: {query_name}",
            "is_malicious": True,
        }

    def generate_benign_event(self, timestamp: str) -> Dict[str, Any]:
        """
        Normal HTTP/DNS traffic — the background noise detections
        must filter out to avoid false positives.
        """
        if self.protocol == "dns":
            return self._generate_benign_dns(timestamp)
        return self._generate_benign_http(timestamp)

    def _generate_benign_http(self, timestamp: str) -> Dict[str, Any]:
        """Normal web browsing traffic."""
        host_name, host_info = random.choice(list(config.TARGET_HOSTS.items()))
        domain = random.choice(self.LEGIT_DOMAINS)

        return {
            "timestamp": timestamp,
            "event_type": "http_request",
            "hostname": host_name,
            "src_ip": host_info["ip"],
            "dst_ip": f"{random.randint(1,223)}.{random.randint(0,255)}.{random.randint(0,255)}.{random.randint(1,254)}",
            "dst_port": 443,
            "method": "GET",
            "url": f"https://{domain}/{random.choice(['index.html', 'api/status', 'assets/logo.png'])}",
            "domain": domain,
            "status_code": 200,
            "bytes_out": random.randint(100, 500),
            "bytes_in": random.randint(1000, 50000),
            "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/121.0.0.0",
            "severity": 6,
            "message": f"Normal HTTP traffic from {host_info['ip']} to {domain}",
            "is_malicious": False,
        }

    def _generate_benign_dns(self, timestamp: str) -> Dict[str, Any]:
        """Normal DNS lookup."""
        host_name, host_info = random.choice(list(config.TARGET_HOSTS.items()))
        domain = random.choice(self.LEGIT_DOMAINS)

        return {
            "timestamp": timestamp,
            "event_type": "dns_query",
            "hostname": host_name,
            "src_ip": host_info["ip"],
            "dst_ip": "10.0.2.5",
            "dst_port": 53,
            "query_name": domain,
            "query_type": "A",
            "domain": domain,
            "subdomain_length": 0,
            "response_code": "NOERROR",
            "severity": 6,
            "message": f"Normal DNS query from {host_info['ip']}: {domain}",
            "is_malicious": False,
        }

    def _generate_timestamps(self) -> List[str]:
        """
        Override base to produce beacon-like intervals for malicious events.
        Uses fixed interval + jitter to mimic real C2 timing.
        """
        now = datetime.utcnow()
        start = now - timedelta(hours=self.time_span_hours)
        timestamps = []

        # Beacon timestamps: regular intervals with jitter
        beacon_time = start
        malicious_count = int(self.event_count * (1 - self.benign_ratio))
        for _ in range(malicious_count):
            jitter_offset = self.beacon_interval * self.jitter * random.uniform(-1, 1)
            interval = self.beacon_interval + jitter_offset
            beacon_time += timedelta(seconds=max(interval, 5))
            if beacon_time > now:
                beacon_time = start + timedelta(seconds=random.randint(0, self.time_span_hours * 3600))
            timestamps.append(beacon_time.strftime("%Y-%m-%dT%H:%M:%S.%fZ"))

        # Benign timestamps: random distribution
        benign_count = self.event_count - malicious_count
        for _ in range(benign_count):
            offset = random.uniform(0, self.time_span_hours * 3600)
            ts = start + timedelta(seconds=offset)
            timestamps.append(ts.strftime("%Y-%m-%dT%H:%M:%S.%fZ"))

        return sorted(timestamps)


# ── CLI Entry Point ──────────────────────────────────────────
def main():
    parser = argparse.ArgumentParser(
        description="Generate C2 beaconing / malware callback logs"
    )
    parser.add_argument("--events", type=int, default=200)
    parser.add_argument("--beacon-interval", type=int, default=60,
                        help="Seconds between C2 callbacks (default: 60)")
    parser.add_argument("--jitter", type=float, default=0.1,
                        help="Timing jitter 0.0-1.0 (default: 0.1)")
    parser.add_argument("--protocol", choices=["http", "dns"], default="http")
    parser.add_argument("--format", choices=["json", "syslog", "cef"], default="json")
    parser.add_argument("--time-span", type=int, default=24)
    args = parser.parse_args()

    simulator = MalwareCallbackSimulator(
        beacon_interval=args.beacon_interval,
        jitter=args.jitter,
        protocol=args.protocol,
        event_count=args.events,
        log_format=args.format,
        time_span_hours=args.time_span,
    )
    simulator.run()


if __name__ == "__main__":
    main()
